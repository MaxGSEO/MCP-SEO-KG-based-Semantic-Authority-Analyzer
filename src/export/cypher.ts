import { EntityGraph, GraphNode } from '../types/index.js';
import { ExportOptions } from '../types/addon.js';
import { writeFileSync } from 'fs';

export function exportToCypher(
  graph: EntityGraph,
  outputPath: string,
  options: ExportOptions = {}
): number {
  const {
    includeMetrics = true,
    includeClusters = true,
    cypherMode = 'create',
    neo4jLabels = ['Entity'],
    neo4jRelType = 'COOCCURS_WITH'
  } = options;

  const lines: string[] = [];

  // Header comment
  lines.push('// Generated by SEO Semantic Authority Analyzer');
  lines.push(`// Mode: ${cypherMode.toUpperCase()}`);
  lines.push(`// Nodes: ${graph.nodes.length}, Edges: ${graph.edges.length}`);
  lines.push('');

  if (cypherMode === 'create') {
    exportCreateMode(lines, graph, neo4jLabels, neo4jRelType, includeMetrics, includeClusters);
  } else {
    exportMergeMode(lines, graph, neo4jLabels, neo4jRelType, includeMetrics, includeClusters);
  }

  const content = lines.join('\n');
  writeFileSync(outputPath, content, 'utf-8');

  return Buffer.byteLength(content, 'utf-8');
}

function exportCreateMode(
  lines: string[],
  graph: EntityGraph,
  labels: string[],
  relType: string,
  includeMetrics: boolean,
  includeClusters: boolean
): void {
  const labelStr = labels.map(l => `:${l}`).join('');

  // Create constraint (optional, commented out)
  lines.push('// Optional: Create unique constraint');
  lines.push(`// CREATE CONSTRAINT IF NOT EXISTS FOR (e${labelStr}) REQUIRE e.id IS UNIQUE;`);
  lines.push('');

  // Create nodes
  lines.push('// Create nodes');
  for (const node of graph.nodes) {
    const props = buildNodeProps(node, includeMetrics, includeClusters);
    lines.push(`CREATE (${labelStr} ${props});`);
  }
  lines.push('');

  // Create relationships
  lines.push('// Create relationships');
  lines.push('// Note: Run after nodes are created');
  for (const edge of graph.edges) {
    const weight = edge.weight ?? 1;
    lines.push(
      `MATCH (a${labelStr} {id: ${escapeStr(edge.source)}}), ` +
      `(b${labelStr} {id: ${escapeStr(edge.target)}}) ` +
      `CREATE (a)-[:${relType} {weight: ${weight}}]->(b);`
    );
  }
}

function exportMergeMode(
  lines: string[],
  graph: EntityGraph,
  labels: string[],
  relType: string,
  includeMetrics: boolean,
  includeClusters: boolean
): void {
  const labelStr = labels.map(l => `:${l}`).join('');

  // Create constraint (recommended for MERGE)
  lines.push('// Recommended: Create unique constraint for efficient MERGE');
  lines.push(`CREATE CONSTRAINT IF NOT EXISTS FOR (e${labelStr}) REQUIRE e.id IS UNIQUE;`);
  lines.push('');

  // Merge nodes
  lines.push('// Merge nodes (idempotent - safe to re-run)');
  for (const node of graph.nodes) {
    const setProps = buildSetProps(node, includeMetrics, includeClusters);
    lines.push(
      `MERGE (n${labelStr} {id: ${escapeStr(node.id)}}) ` +
      `ON CREATE SET ${setProps} ` +
      `ON MATCH SET ${setProps};`
    );
  }
  lines.push('');

  // Merge relationships
  lines.push('// Merge relationships (idempotent)');
  for (const edge of graph.edges) {
    const weight = edge.weight ?? 1;
    lines.push(
      `MATCH (a${labelStr} {id: ${escapeStr(edge.source)}}), ` +
      `(b${labelStr} {id: ${escapeStr(edge.target)}}) ` +
      `MERGE (a)-[r:${relType}]->(b) ` +
      `ON CREATE SET r.weight = ${weight} ` +
      `ON MATCH SET r.weight = ${weight};`
    );
  }
}

function buildNodeProps(
  node: GraphNode,
  includeMetrics: boolean,
  includeClusters: boolean
): string {
  const props: string[] = [
    `id: ${escapeStr(node.id)}`,
    `name: ${escapeStr(node.entity.name)}`,
    `type: ${escapeStr(node.entity.type)}`
  ];

  if (node.entity.wikidataId) {
    props.push(`wikidataId: ${escapeStr(node.entity.wikidataId)}`);
  }
  if (node.entity.wikipediaUrl) {
    props.push(`wikipediaUrl: ${escapeStr(node.entity.wikipediaUrl)}`);
  }

  if (includeMetrics) {
    if (node.betweennessCentrality != null) {
      props.push(`betweennessCentrality: ${node.betweennessCentrality}`);
    }
    if (node.degreeCentrality != null) {
      props.push(`degreeCentrality: ${node.degreeCentrality}`);
    }
    props.push(`relevance: ${node.entity.relevance ?? 0}`);
    props.push(`confidence: ${node.entity.confidence ?? 0}`);
  }

  if (includeClusters && node.cluster != null) {
    props.push(`cluster: ${node.cluster}`);
  }

  return `{${props.join(', ')}}`;
}

function buildSetProps(
  node: GraphNode,
  includeMetrics: boolean,
  includeClusters: boolean
): string {
  const props: string[] = [
    `n.name = ${escapeStr(node.entity.name)}`,
    `n.type = ${escapeStr(node.entity.type)}`
  ];

  if (node.entity.wikidataId) {
    props.push(`n.wikidataId = ${escapeStr(node.entity.wikidataId)}`);
  }
  if (node.entity.wikipediaUrl) {
    props.push(`n.wikipediaUrl = ${escapeStr(node.entity.wikipediaUrl)}`);
  }

  if (includeMetrics) {
    if (node.betweennessCentrality != null) {
      props.push(`n.betweennessCentrality = ${node.betweennessCentrality}`);
    }
    if (node.degreeCentrality != null) {
      props.push(`n.degreeCentrality = ${node.degreeCentrality}`);
    }
    props.push(`n.relevance = ${node.entity.relevance ?? 0}`);
    props.push(`n.confidence = ${node.entity.confidence ?? 0}`);
  }

  if (includeClusters && node.cluster != null) {
    props.push(`n.cluster = ${node.cluster}`);
  }

  props.push(`n.updatedAt = datetime()`);

  return props.join(', ');
}

function escapeStr(str: string): string {
  if (!str) return '""';
  return `"${str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
}
